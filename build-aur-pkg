#!/usr/bin/env bash

## this script will build AUR packages which have been previously
## cloned. The script *does not* read any pkglist, or other user
## input. It builds all cloned packages located in {PKGDIR}.

## The script expects all package AUR dependencies to be already
## resolved, any missing repos will lead to failure.

## Some packages are part of package-bases which are a type of
## meta package. This script has rudimentry way of detecting
## and building. Because of limitations with makepkg, all packages
## part of the package-base will be built - even if the user
## does not want this.

readonly ROOTDIR="$HOME"

readonly PKGDIR="aur-src"
readonly PKGPATH="$ROOTDIR/$PKGDIR"
readonly DB="viesspkg"

parse_srcinfo() {
    ## print out pkgnames with version info
    local file
    local pkgver

    file="$1/.SRCINFO"
    pkgver="$(grep pkgver "$file" | cut -d' ' -f3)"

    grep pkgname "$file" | cut -d' ' -f3 | sort | sed "s|\$|\t$pkgver|"
}

uniq_unsorted() {
    # remove all duplicate lines *without* changing the general order of lines
    cat -n "$1" | sort -uk2 | sort -nk2 | cut -f2-
}

tmp="$(mktemp -d)"
if [ ! -d "$tmp" ]; then
    echo "Unable to create temp directory!" >&2
    exit 2
fi
trap 'rm -rf $tmp' EXIT

if [ ! -d "$PKGPATH" ]; then
    echo "Must be run relative to $PKGPATH" >&2
    exit 1
fi

# get all currently fetched aur pkgs
find "$PKGPATH" -mindepth 1 -maxdepth 1 -type d -printf "%P\n" | sort > "$tmp/pkgdirs"

pushd "$tmp"

# retrieve path to local repo
aur repo -S -d "$DB" --list --status-file=db | sort > db_info

{ IFS= read -r db_name
  IFS= read -r db_root
} < "$tmp/db"

if [[ -w $db_root/$db_name.db ]]; then
    echo "Using [$db_name] repository" >&2
else
    echo "Error: $db_root/$db_name.db: permission denied" >&2
    exit 1
fi

# collect all pkgs that have been updated (in AUR!)
aur vercmp --quiet < db_info > aurupdate
cut -f1 aurupdate > aurupdate.pkgname

# parse srcinfo (for pkgnames)
while read -r pkgdir; do
    echo "=> Checking pkgbase \`$pkgdir'"
    echo "==> Parsing .SRCINFO"
    parse_srcinfo "$PKGPATH/$pkgdir" > "$pkgdir.depends"
    cut -f1 "$pkgdir.depends" > "$pkgdir"
    echo "==> Checking if new or updated"
    cut -f1 db_info | comm -13 - "$pkgdir" > "$pkgdir.new"
    comm -12 aurupdate.pkgname "$pkgdir" > "$pkgdir.update"

    if [ -s "$pkgdir.new" ] || [ -s "$pkgdir.update" ]; then
        echo "==> Added \`$pkgdir' to build queue"
        if ! aur depends -b "$pkgdir" 2> /dev/null >> pkgord; then
            # pkgdir is a group of pkgs
            echo "$pkgdir" >> pkgord
        fi
    else
        echo "==> Already latest, skipping..."
    fi
done < pkgdirs

if [ -s pkgord ]; then
    uniq_unsorted pkgord | sed "s|^\(.*\)$|$PKGDIR\/\1|" > queue
fi

popd

if [ -s "$tmp/queue" ]; then
    xargs -a "$tmp/queue" -n1 -P1 -I{} echo "=> Building {}"
    aur build -a "$tmp/queue" -c -d "$DB" -s
else
    echo "Nothing to build"
fi
